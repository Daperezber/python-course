\documentclass[aspectratio=1610,slidestop]{beamer}

\author{Mihai Lefter}
\title{Python Programming}
\providecommand{\mySubTitle}{Flow Control}
\providecommand{\myConference}{Programming Course}
\providecommand{\myDate}{27-11-2018}
\providecommand{\myGroup}{}
\providecommand{\myDepartment}{}
\providecommand{\myCenter}{}

\usetheme{lumc}

\usepackage{minted}
\usepackage{tikz}
\usepackage[many]{tcolorbox}

\definecolor{monokaibg}{HTML}{272822}
\definecolor{emailc}{HTML}{1e90FF}
\definecolor{scriptback}{HTML}{CDECF0}

\newenvironment{ipython}
 {\begin{tcolorbox}[title=IPython,
                   title filled=false,
                   fonttitle=\scriptsize,
                   fontupper=\footnotesize,
                   enhanced,
                   colback=monokaibg,
                   drop small lifted shadow,
                   boxrule=0.1mm,
                   left=0.1cm,
                   arc=0mm,
                   colframe=black]}
 {\end{tcolorbox}}


\newenvironment{terminal}
 {\begin{tcolorbox}[title=terminal,
                   title filled=false,
                   fonttitle=\scriptsize,
                   fontupper=\footnotesize,
                   enhanced,
                   colback=monokaibg,
                   drop small lifted shadow,
                   boxrule=0.1mm,
                   left=0.1cm,
                   arc=0mm,
                   colframe=black]}
 {\end{tcolorbox}}


\newcommand{\hrefcc}[2]{\textcolor{#1}{\href{#2}{#2}}}
\newcommand{\hrefc}[3]{\textcolor{#1}{\href{#2}{#3}}}

\newcounter{cntr}
\renewcommand{\thecntr}{\texttt{[\arabic{cntr}]}}

\newenvironment{pythonin}[1]
{\VerbatimEnvironment
  \begin{minipage}[t]{0.11\linewidth}
   \textcolor{green}{\texttt{{\refstepcounter{cntr}\label{#1}In \thecntr:}}}
  \end{minipage}
  \begin{minipage}[t]{0.89\linewidth}
  \begin{minted}[
    breaklines=true,style=monokai]{#1}}
 {\end{minted}
 \end{minipage}}

\newenvironment{pythonout}[1]
{\VerbatimEnvironment
  \addtocounter{cntr}{-1}
  \begin{minipage}[t]{0.11\linewidth}
   \textcolor{red}{\texttt{{\refstepcounter{cntr}\label{#1}Out\thecntr:}}}
  \end{minipage}
  \begin{minipage}[t]{0.89\linewidth}
  \begin{minted}[
    breaklines=true,style=monokai]{#1}}
 {\end{minted}
 \end{minipage}}

\newenvironment{pythonerr}[1]
{\VerbatimEnvironment
  \begin{minted}[
    breaklines=true,style=monokai]{#1}}
 {\end{minted}}


\newenvironment{pythonfile}[1]
 {\begin{tcolorbox}[title=#1,
                    title filled=false,
                    coltitle=LUMCDonkerblauw,
                    fonttitle=\scriptsize,
                    fontupper=\footnotesize,
                    enhanced,
                    drop small lifted shadow,
                    boxrule=0.1mm,
                    leftrule=5mm,
                    rulecolor=white,
                    left=0.1cm,
                    colback=white!92!black,
                    colframe=scriptback]}
 {\end{tcolorbox}}

\begin{document}

% This disables the \pause command, handy in the editing phase.
%\renewcommand{\pause}{}

% Make the title slide.
\makeTitleSlide{\includegraphics[height=3.5cm]{../../images/Python.pdf}}

% First page of the presentation.
\section{Introduction}
\makeTableOfContents


\section{Working with scripts}

\begin{pframe}
 Interpreters are great for prototyping, but not really suitable if you want to
 share or release code. To do so, we write our Python commands in scripts (and
 later, modules).

 A script is a simple text file containing Python instructions to execute.
\end{pframe}


\subsection{Executing scripts}
\begin{pframe}
 There are two common ways to execute a script:
  \begin{itemize}
   \item As an argument of the Python interpreter command.
   \item As a standalone executable (with the appropriate shebang line and
   file mode).
  \end{itemize}
  \medskip

  IPython gives you a third option:
  \begin{itemize}
   \item As an argument of the \lstinline{%run} magic.
  \end{itemize}
\end{pframe}


\subsection{Writing your script}
\begin{pframe}
 Let's start with a simple GC calculator. Open your text editor, and write the
 following Python statements (remember your indentations):

 \begin{pythonfile}{first\_script.py}
  \begin{minted}[linenos]{python}
print("Hello world!")
  \end{minted}
 \end{pythonfile}
Save the file as first\_script.py and go to your shell.
\end{pframe}

\subsection{Running the script}
\begin{pframe}
 Let's try the first method: using your script as an argument:
 \begin{terminal}
  \color{white}{
  \begin{lstlisting}[frame=,style=,numbers=none]
$ python first_script.py
  \end{lstlisting}}
 \end{terminal}
  Is the output as you expect?
\end{pframe}

\begin{pframe}
  For the second method, we need to do two more things:
  \begin{itemize}
   \item Open the script in your editor and add the following line to the very
   top:
   \begin{itemize}
    \item \mintinline{python}{#!/usr/bin/env python}
   \end{itemize}
   \item Save the file, go back to the shell, and allow the file to be executed.
  \end{itemize}
 \begin{terminal}
  \color{white}{
  \begin{lstlisting}[frame=,style=,numbers=none]
$ chmod +x first_script.py
  \end{lstlisting}}
 \end{terminal}
You can now execute the file directly:
\begin{terminal}
  \color{white}{
  \begin{lstlisting}[frame=,style=,numbers=none]
$ ./first_script.py
  \end{lstlisting}}
 \end{terminal}
 Is the output the same as the previous method?
\end{pframe}

\begin{pframe}
 Finally, try out the third method. Open an IPython interpreter session and do:
 \begin{ipython}
  \begin{pythonin}{python}
%run seq_toolbox.py
  \end{pythonin}
 \end{ipython}
\end{pframe}


\section{Conditionals}

\subsection{if statements}
\begin{pframe}
 \begin{pythonfile}{if.py}
  \begin{minted}[linenos]{python}
if 26 <= 17:
    print('Fact: 26 is less than or equal to 17')
elif (26 + 8 > 14) == True:
    print('Did we need the ` == True` part here?')
else:
    print('Nothing seems true')
  \end{minted}
 \end{pythonfile}

 \begin{terminal}
  \color{white}{
  \begin{lstlisting}[frame=,style=,numbers=none]
$ python if.py
Did we need the ` == True` part here?
  \end{lstlisting}}
 \end{terminal}
\end{pframe}


\section{Loops}

\subsection{while statements}
\begin{pframe}
 \begin{pythonfile}{while.py}
  \begin{minted}[linenos]{python}
i = 0
while i < 5:
    print(i)
    i += 1
  \end{minted}
 \end{pythonfile}

 \begin{terminal}
  \color{white}{
  \begin{lstlisting}[frame=,style=,numbers=none]
$ python while.py
0
1
2
3
4
  \end{lstlisting}}
 \end{terminal}
\end{pframe}

\subsection{Iterating over a sequence}
\begin{pframe}
 \begin{pythonfile}{for.py}
  \begin{minted}[linenos]{python}
colors = ['red', 'white', 'blue', 'orange']
cities = ['leiden', 'utrecht', 'warmond', 'san francisco']

# The for statement can iterate over sequence items.
for color in colors:
    print(color)

for character in 'blue':
    print(character)
  \end{minted}
 \end{pythonfile}
\end{pframe}

\begin{pframe}
 \begin{terminal}
  \color{white}{
  \begin{lstlisting}[frame=,style=,numbers=none]
$ python for.py
red
white
blue
orange
b
l
u
e  \end{lstlisting}}
 \end{terminal}
\end{pframe}



\section{Functions}

\subsection{Defining a function}
\begin{pframe}
 A function is a named sequence of statements that performs some piece of work.
 Later on that function can be called by using its name.
 \medskip

 A function definition includes its name, arguments and body.
 \begin{pythonfile}{functions.py}
  \begin{minted}[linenos]{python}
def add_two(number):
    return number + 2

for i in range(5):
    print add_two(i)
  \end{minted}
 \end{pythonfile}
\end{pframe}


\subsection{Keyword arguments}
\begin{pframe}
 Besides regular arguments, functions can have keyword arguments.
 \begin{pythonfile}{functions\_keywords.py}
  \begin{minted}[linenos]{python}
def add_some_other_number(number, other_number=12):
    return number + other_number

add_some_other_number(2, 6)

add_some_other_number(3, other_number=4)

add_some_other_number(5)
  \end{minted}
 \end{pythonfile}
\end{pframe}


\subsection{Functions are values}
\begin{pframe}
 We can pass functions around just like other values, and call them.
 \begin{pythonfile}{function\_values.py}
  \begin{minted}[linenos]{python}
functions = [add_two, add_some_other_number]
for function in functions:
    print function(7)

# Simple anonymous functions can be created with lambda.
functions.append(lambda x: x * 7)
for function in functions:
    print function(4)
  \end{minted}
 \end{pythonfile}
\end{pframe}


\subsection{Docstrings}
\begin{pframe}
 Like many other definitions, functions can have docstrings.
 \begin{itemize}
  \item Docstrings are regular string values which you start the definition
  body with.
  \item You can access an object's docstring using help.
 \end{itemize}

 \begin{ipython}
  \begin{pythonin}{python}
help(map)
Help on class map in module builtins:

class map(object)
 |  map(func, *iterables) --> map object
 |
 |  Make an iterator that computes the function using arguments from
 |  each of the iterables.  Stops when the shortest iterable is exhausted.
  \end{pythonin}
  \\

 \begin{pythonin}{python}
list(map(add_two, [1, 2, 3, 4]))
  \end{pythonin}
  \\
  \begin{pythonout}{python}
[3, 4, 5, 6]
  \end{pythonout}
 \end{ipython}
\end{pframe}


\section{Hands on!}
\begin{pframe}
 \vspace{-0.5cm}
 \begin{enumerate}
  \item Write a Python function that returns the maximum of two numbers.
  \item Write a Python function that returns the maximum of three numbers.
  Try to reuse the first maximum of two numbers function.
  \item Write a Python function that accepts a string as parameter.
  Next, it calculates and prints the number of upper case letters and lower
  case letters. Make us of the \mintinline{python}{isupper} and
  \mintinline{python}{islower} built in methods.


 \end{enumerate}
\end{pframe}


% Make the acknowledgements slide.
\makeAcknowledgementsSlide{
  \begin{tabular}{ll}
    Martijn Vermaat\\
    Jeroen Laros\\
    Jonathan Vis
  \end{tabular}
}

\end{document}
